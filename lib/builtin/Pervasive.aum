--
-- Part of the Austral project, under the Apache License v2.0 with LLVM Exceptions.
-- See LICENSE file for details.
--
-- SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
--
module body Austral.Pervasive is
    generic [T: Type, R: Region]
    function spanLength(sp: Span[T, R]): Index is
        return @embed(Index, "$1.size", sp);
    end;

    generic [T: Type, R: Region]
    function spanWriteLength(sp: Span![T, R]): Index is
        return @embed(Index, "$1.size", sp);
    end;
    
    function abort(message: Span[Nat8, Static]): Unit is
        return @embed(Unit, "au_abort($1)", message);
    end;

    record RootCapability: Linear is
        value: Unit;
    end;

    function surrenderRoot(cap: RootCapability): Unit is
        let { value: Unit } := cap;
        return nil;
    end;

    function argumentCount(): Index is
        return @embed(Index, "au_get_argc()");
    end;

    function nthArgument(n: Index): Span[Nat8, Static] is
        return @embed(Span[Nat8, Static], "au_get_nth_arg($1)", n);
    end;

    constant minimum_nat8: Int8 := 0;
    constant maximum_nat8: Nat8 := @embed(Nat8, "UINT8_MAX");

    constant minimum_nat16: Int8 := 0;
    constant maximum_nat16: Nat16 := @embed(Nat16, "UINT16_MAX");

    constant minimum_nat32: Int8 := 0;
    constant maximum_nat32: Nat32 := @embed(Nat32, "UINT32_MAX");

    constant minimum_nat64: Int8 := 0;
    constant maximum_nat64: Nat64 := @embed(Nat64, "UINT64_MAX");

    constant minimum_int8: Int8 := @embed(Int8, "INT8_MIN");
    constant maximum_int8: Int8 := @embed(Int8, "INT8_MAX");

    constant minimum_int16: Int16 := @embed(Int16, "INT16_MIN");
    constant maximum_int16: Int16 := @embed(Int16, "INT16_MAX");

    constant minimum_int32: Int32 := @embed(Int32, "INT32_MIN");
    constant maximum_int32: Int32 := @embed(Int32, "INT32_MAX");

    constant minimum_int64: Int64 := @embed(Int64, "INT64_MIN");
    constant maximum_int64: Int64 := @embed(Int64, "INT64_MAX");

    constant minimum_index: Index := 0;
    constant maximum_index: Index := @embed(Index, "SIZE_MAX");

    constant minimum_bytesize: ByteSize := 0;
    constant maximum_bytesize: ByteSize := @embed(ByteSize, "SIZE_MAX");

    ---
    --- Trapping Arithmetic
    ---

    instance TrappingArithmetic(Nat8) is
        method trappingAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Nat8)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Nat8)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            let result: Nat8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Nat8)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int8) is
        method trappingAdd(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Int8)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Int8)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int8, rhs: Int8): Int8 is
            let result: Int8 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Int8)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Int8)");
            end if;
            if (lhs = minimum_int8) and (rhs = -1) then
                abort("Overflow in trappingDivide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat16) is
        method trappingAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Nat16)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Nat16)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            let result: Nat16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Nat16)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int16) is
        method trappingAdd(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Int16)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Int16)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int16, rhs: Int16): Int16 is
            let result: Int16 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Int16)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Int16)");
            end if;
            if (lhs = minimum_int16) and (rhs = -1) then
                abort("Overflow in trappingDivide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat32) is
        method trappingAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Nat32)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Nat32)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            let result: Nat32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Nat32)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int32) is
        method trappingAdd(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Int32)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Int32)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int32, rhs: Int32): Int32 is
            let result: Int32 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Int32)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Int32)");
            end if;
            if (lhs = minimum_int32) and (rhs = -1) then
                abort("Overflow in trappingDivide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Nat64) is
        method trappingAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Nat64)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Nat64)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            let result: Nat64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Nat64)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Int64) is
        method trappingAdd(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Int64)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Int64)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Int64, rhs: Int64): Int64 is
            let result: Int64 := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Int64)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Int64)");
            end if;
            if (lhs = minimum_int64) and (rhs = -1) then
                abort("Overflow in trappingDivide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Index) is
        method trappingAdd(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (Index)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (Index)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: Index, rhs: Index): Index is
            let result: Index := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (Index)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(ByteSize) is
        method trappingAdd(lhs: ByteSize, rhs: ByteSize): ByteSize is
            let result: ByteSize := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_add_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingAdd (ByteSize)");
            end if;
            return result;
        end;

        method trappingSubtract(lhs: ByteSize, rhs: ByteSize): ByteSize is
            let result: ByteSize := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_sub_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingSubtract (ByteSize)");
            end if;
            return result;
        end;

        method trappingMultiply(lhs: ByteSize, rhs: ByteSize): ByteSize is
            let result: ByteSize := 0;
            let did_overflow: Bool := @embed(Bool, "__builtin_mul_overflow($1, $2, &$3)", lhs, rhs, result);
            if did_overflow then
                abort("Overflow in trappingMultiply (ByteSize)");
            end if;
            return result;
        end;

        method trappingDivide(lhs: ByteSize, rhs: ByteSize): ByteSize is
            if rhs = 0 then
                abort("Division by zero in trappingDivide (ByteSize)");
            end if;
            return @embed(ByteSize, "$1 / $2", lhs, rhs);
        end;
    end;

    instance TrappingArithmetic(Float64) is
        method trappingAdd(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 + $2", lhs, rhs);
        end;

        method trappingSubtract(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 - $2", lhs, rhs);
        end;

        method trappingMultiply(lhs: Float64, rhs: Float64): Float64 is
            return @embed(Float64, "$1 * $2", lhs, rhs);
        end;

        method trappingDivide(lhs: Float64, rhs: Float64): Float64 is
            if rhs = 0.0 then
                abort("Division by zero in trappingDivide (Float64)");
            end if;
            return @embed(Float64, "$1 / $2", lhs, rhs);
        end;
    end;


    ---
    --- Modular Arithmetic
    ---

    instance ModularArithmetic(Nat8) is
        method modularAdd(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat8)");
            end if;
            return @embed(Nat8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int8) is
        method modularAdd(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int8)");
            end if;
            return @embed(Int8, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat16) is
        method modularAdd(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat16)");
            end if;
            return @embed(Nat16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int16) is
        method modularAdd(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int16)");
            end if;
            return @embed(Int16, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat32) is
        method modularAdd(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat32)");
            end if;
            return @embed(Nat32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int32) is
        method modularAdd(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int32)");
            end if;
            return @embed(Int32, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Nat64) is
        method modularAdd(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Nat64)");
            end if;
            return @embed(Nat64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Int64) is
        method modularAdd(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Int64)");
            end if;
            return @embed(Int64, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(Index) is
        method modularAdd(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
                abort("Division by zero in modularDivide (Index)");
            end if;
            return @embed(Index, "$1 / $2", lhs, rhs);
        end;
    end;

    instance ModularArithmetic(ByteSize) is
        method modularAdd(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 + $2", lhs, rhs);
        end;

        method modularSubtract(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 - $2", lhs, rhs);
        end;

        method modularMultiply(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 * $2", lhs, rhs);
        end;

        method modularDivide(lhs: ByteSize, rhs: ByteSize): ByteSize is
            if rhs = 0 then
                abort("Division by zero in modularDivide (ByteSize)");
            end if;
            return @embed(ByteSize, "$1 / $2", lhs, rhs);
        end;
    end;

    ---
    --- Bitwise Operations
    ---

    instance BitwiseOperations(Nat8) is
        method bitwiseAnd(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Nat8, rhs: Nat8): Nat8 is
            return @embed(Nat8, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Nat8): Nat8 is
            return @embed(Nat8, "~ $1", value);
        end;

    end;

    instance BitwiseOperations(Int8) is
        method bitwiseAnd(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Int8, rhs: Int8): Int8 is
            return @embed(Int8, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Int8): Int8 is
            return @embed(Int8, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Nat16) is
        method bitwiseAnd(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Nat16, rhs: Nat16): Nat16 is
            return @embed(Nat16, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Nat16): Nat16 is
            return @embed(Nat16, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Int16) is
        method bitwiseAnd(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Int16, rhs: Int16): Int16 is
            return @embed(Int16, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Int16): Int16 is
            return @embed(Int16, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Nat32) is
        method bitwiseAnd(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Nat32, rhs: Nat32): Nat32 is
            return @embed(Nat32, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Nat32): Nat32 is
            return @embed(Nat32, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Int32) is
        method bitwiseAnd(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Int32, rhs: Int32): Int32 is
            return @embed(Int32, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Int32): Int32 is
            return @embed(Int32, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Nat64) is
        method bitwiseAnd(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Nat64, rhs: Nat64): Nat64 is
            return @embed(Nat64, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Nat64): Nat64 is
            return @embed(Nat64, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Int64) is
        method bitwiseAnd(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Int64, rhs: Int64): Int64 is
            return @embed(Int64, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Int64): Int64 is
            return @embed(Int64, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(Index) is
        method bitwiseAnd(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: Index, rhs: Index): Index is
            return @embed(Index, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: Index): Index is
            return @embed(Index, "~ $1", value);
        end;
    end;

    instance BitwiseOperations(ByteSize) is
        method bitwiseAnd(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 & $2", lhs, rhs);
        end;

        method bitwiseOr(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 | $2", lhs, rhs);
        end;

        method bitwiseXor(lhs: ByteSize, rhs: ByteSize): ByteSize is
            return @embed(ByteSize, "$1 ^ $2", lhs, rhs);
        end;

        method bitwiseNot(value: ByteSize): ByteSize is
            return @embed(ByteSize, "~ $1", value);
        end;
    end;

    ---
    --- Printable
    ---

    instance Printable(Unit) is
        method print(value: Unit): Unit is
            return @embed(Unit, "au_printf(\"nil\")");
            return value;
        end;
    end;

    instance Printable(Bool) is
        method print(value: Bool): Unit is
            if value then
                @embed(Unit, "au_printf(\"true\")");
            else
                @embed(Unit, "au_printf(\"false\")");
            end if;
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Unit, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat8) is
        method print(value: Nat8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Nat8, R]): Unit is
            if @embed(Index, "$1.size", array) > 0 then
                for i from 0 to @embed(Index, "$1.size", array) - 1 do
                    @embed(Unit, "au_printf(\"%c\", $1)", array[i]);
                end for;
            end if;
            return nil;
        end;
    end;

    instance Printable(Nat16) is
        method print(value: Nat16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Nat16, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat32) is
        method print(value: Nat32): Unit is
            return @embed(Unit, "au_printf(\"%u\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Nat32, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Nat64) is
        method print(value: Nat64): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Nat64, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int8) is
        method print(value: Int8): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Int8, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int16) is
        method print(value: Int16): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Int16, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int32) is
        method print(value: Int32): Unit is
            return @embed(Unit, "au_printf(\"%i\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Int32, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Int64) is
        method print(value: Int64): Unit is
            return @embed(Unit, "au_printf(\"%li\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Int64, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Index) is
        method print(value: Index): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Index, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(ByteSize) is
        method print(value: ByteSize): Unit is
            return @embed(Unit, "au_printf(\"%zu\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[ByteSize, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float32) is
        method print(value: Float32): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Float32, R]): Unit is
            return nil;
        end;
    end;

    instance Printable(Float64) is
        method print(value: Float64): Unit is
            return @embed(Unit, "au_printf(\"%f\", $1)", value);
            return nil;
        end;

        generic [R: Region]
        method printSpan(array: Span[Float64, R]): Unit is
            return nil;
        end;
    end;

    generic [B: Free(Printable), R: Region]
    instance Printable(Span[B, R]) is
        method print(value: Span[B, R]): Unit is
            return printSpan(value);
        end;

        generic [S: Region]
        method printSpan(array: Span[Span[B, R], S]): Unit is
            return nil;
        end;
    end;

    generic [T: Free(Printable)]
    function printLn(value: T): Unit is
        print(value);
        return @embed(Unit, "au_printf(\"\n\")");
    end;

    ---
    --- Integer conversions.
    ---

    --- ToNat8

    instance ToNat8(Nat8) is
        method toNat8(value: Nat8): Option[Nat8] is
            return Some(value => value);
        end;
    end;

    instance ToNat8(Nat16) is
        method toNat8(value: Nat16): Option[Nat8] is
            if value <= @embed(Nat16, "UINT8_MAX") then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Nat32) is
        method toNat8(value: Nat32): Option[Nat8] is
            if value <= @embed(Nat32, "UINT8_MAX") then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Nat64) is
        method toNat8(value: Nat64): Option[Nat8] is
            if value <= @embed(Nat64, "UINT8_MAX") then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Int8) is
        method toNat8(value: Int8): Option[Nat8] is
            if value >= 0 then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Int16) is
        method toNat8(value: Int16): Option[Nat8] is
            if (value >= 0) and (value <= @embed(Int16, "UINT8_MAX")) then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Int32) is
        method toNat8(value: Int32): Option[Nat8] is
            if (value >= 0) and (value <= @embed(Int32, "UINT8_MAX")) then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Int64) is
        method toNat8(value: Int64): Option[Nat8] is
            if (value >= 0) and (value <= @embed(Int64, "UINT8_MAX")) then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Index) is
        method toNat8(value: Index): Option[Nat8] is
            if (value >= 0) and (value <= @embed(Index, "UINT8_MAX")) then
                return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat8(Float32) is
        method toNat8(value: Float32): Option[Nat8] is
            return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
        end;
    end;

    instance ToNat8(Float64) is
        method toNat8(value: Float64): Option[Nat8] is
            return Some(value => @embed(Nat8, "((au_nat8_t)($1))", value));
        end;
    end;

    --- ToNat16

    instance ToNat16(Nat8) is
        method toNat16(value: Nat8): Option[Nat16] is
            return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
        end;
    end;

    instance ToNat16(Nat16) is
        method toNat16(value: Nat16): Option[Nat16] is
            return Some(value => value);
        end;
    end;

    instance ToNat16(Nat32) is
        method toNat16(value: Nat32): Option[Nat16] is
            if value <= @embed(Nat32, "UINT16_MAX") then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Nat64) is
        method toNat16(value: Nat64): Option[Nat16] is
            if value <= @embed(Nat64, "UINT16_MAX") then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Int8) is
        method toNat16(value: Int8): Option[Nat16] is
            if value >= 0 then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Int16) is
        method toNat16(value: Int16): Option[Nat16] is
            if (value >= 0) then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Int32) is
        method toNat16(value: Int32): Option[Nat16] is
            if (value >= 0) and (value <= @embed(Int32, "UINT16_MAX")) then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Int64) is
        method toNat16(value: Int64): Option[Nat16] is
            if (value >= 0) and (value <= @embed(Int64, "UINT16_MAX")) then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Index) is
        method toNat16(value: Index): Option[Nat16] is
            if (value >= 0) and (value <= @embed(Index, "UINT16_MAX")) then
                return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat16(Float32) is
        method toNat16(value: Float32): Option[Nat16] is
            return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
        end;
    end;

    instance ToNat16(Float64) is
        method toNat16(value: Float64): Option[Nat16] is
            return Some(value => @embed(Nat16, "((au_nat16_t)($1))", value));
        end;
    end;

    -- ToNat32

    instance ToNat32(Nat8) is
        method toNat32(value: Nat8): Option[Nat32] is
            return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
        end;
    end;

    instance ToNat32(Nat16) is
        method toNat32(value: Nat16): Option[Nat32] is
            return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
        end;
    end;

    instance ToNat32(Nat32) is
        method toNat32(value: Nat32): Option[Nat32] is
            return Some(value => value);
        end;
    end;

    instance ToNat32(Nat64) is
        method toNat32(value: Nat64): Option[Nat32] is
            if value <= @embed(Nat64, "UINT32_MAX") then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Int8) is
        method toNat32(value: Int8): Option[Nat32] is
            if value >= 0 then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Int16) is
        method toNat32(value: Int16): Option[Nat32] is
            if value >= 0 then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Int32) is
        method toNat32(value: Int32): Option[Nat32] is
            if value >= 0 then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Int64) is
        method toNat32(value: Int64): Option[Nat32] is
            if (value >= 0) and (value <= @embed(Int64, "UINT32_MAX")) then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Index) is
        method toNat32(value: Index): Option[Nat32] is
            if (value >= 0) and (value <= @embed(Index, "UINT32_MAX")) then
                return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat32(Float32) is
        method toNat32(value: Float32): Option[Nat32] is
            return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
        end;
    end;

    instance ToNat32(Float64) is
        method toNat32(value: Float64): Option[Nat32] is
            return Some(value => @embed(Nat32, "((au_nat32_t)($1))", value));
        end;
    end;

    -- ToNat64

    instance ToNat64(Nat8) is
        method toNat64(value: Nat8): Option[Nat64] is
            return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
        end;
    end;

    instance ToNat64(Nat16) is
        method toNat64(value: Nat16): Option[Nat64] is
            return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
        end;
    end;

    instance ToNat64(Nat32) is
        method toNat64(value: Nat32): Option[Nat64] is
            return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
        end;
    end;

    instance ToNat64(Nat64) is
        method toNat64(value: Nat64): Option[Nat64] is
            return Some(value => value);
        end;
    end;

    instance ToNat64(Int8) is
        method toNat64(value: Int8): Option[Nat64] is
            if value >= 0 then
                return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat64(Int16) is
        method toNat64(value: Int16): Option[Nat64] is
            if value >= 0 then
                return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat64(Int32) is
        method toNat64(value: Int32): Option[Nat64] is
            if value >= 0 then
                return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat64(Int64) is
        method toNat64(value: Int64): Option[Nat64] is
            if value >= 0 then
                return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat64(Index) is
        method toNat64(value: Index): Option[Nat64] is
            if (value >= 0) and (value <= @embed(Index, "UINT64_MAX")) then
                return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToNat64(Float32) is
        method toNat64(value: Float32): Option[Nat64] is
            return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
        end;
    end;

    instance ToNat64(Float64) is
        method toNat64(value: Float64): Option[Nat64] is
            return Some(value => @embed(Nat64, "((au_nat64_t)($1))", value));
        end;
    end;

    -- ToInt8

    instance ToInt8(Nat8) is
        method toInt8(value: Nat8): Option[Int8] is
            if value <= @embed(Nat8, "INT8_MAX") then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Nat16) is
        method toInt8(value: Nat16): Option[Int8] is
            if value <= @embed(Nat16, "INT8_MAX") then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Nat32) is
        method toInt8(value: Nat32): Option[Int8] is
            if value <= @embed(Nat32, "INT8_MAX") then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Nat64) is
        method toInt8(value: Nat64): Option[Int8] is
            if value <= @embed(Nat64, "INT8_MAX") then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Int8) is
        method toInt8(value: Int8): Option[Int8] is
            return Some(value => value);
        end;
    end;

    instance ToInt8(Int16) is
        method toInt8(value: Int16): Option[Int8] is
            if (value >= @embed(Int16, "INT8_MIN")) and (value <= @embed(Int16, "INT8_MAX")) then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Int32) is
        method toInt8(value: Int32): Option[Int8] is
            if (value >= @embed(Int32, "INT8_MIN")) and (value <= @embed(Int32, "INT8_MAX")) then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Int64) is
        method toInt8(value: Int64): Option[Int8] is
            if (value >= @embed(Int64, "INT8_MIN")) and (value <= @embed(Int64, "INT8_MAX")) then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Index) is
        method toInt8(value: Index): Option[Int8] is
            if (value >= @embed(Index, "INT8_MIN")) and (value <= @embed(Index, "INT8_MAX")) then
                return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt8(Float32) is
        method toInt8(value: Float32): Option[Int8] is
            return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
        end;
    end;

    instance ToInt8(Float64) is
        method toInt8(value: Float64): Option[Int8] is
            return Some(value => @embed(Int8, "((au_int8_t)($1))", value));
        end;
    end;

    -- ToInt16

    instance ToInt16(Nat8) is
        method toInt16(value: Nat8): Option[Int16] is
            -- `Nat8` is strictly contained by `Int16`, so no checks are necessary.
            return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
        end;
    end;

    instance ToInt16(Nat16) is
        method toInt16(value: Nat16): Option[Int16] is
            if value <= @embed(Nat16, "INT16_MAX") then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Nat32) is
        method toInt16(value: Nat32): Option[Int16] is
            if value <= @embed(Nat32, "INT16_MAX") then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Nat64) is
        method toInt16(value: Nat64): Option[Int16] is
            if value <= @embed(Nat64, "INT16_MAX") then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Int8) is
        method toInt16(value: Int8): Option[Int16] is
            return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
        end;
    end;

    instance ToInt16(Int16) is
        method toInt16(value: Int16): Option[Int16] is
            return Some(value => value);
        end;
    end;

    instance ToInt16(Int32) is
        method toInt16(value: Int32): Option[Int16] is
            if (value >= @embed(Int32, "INT16_MIN")) and (value <= @embed(Int32, "INT16_MAX")) then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Int64) is
        method toInt16(value: Int64): Option[Int16] is
            if (value >= @embed(Int64, "INT16_MIN")) and (value <= @embed(Int64, "INT16_MAX")) then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Index) is
        method toInt16(value: Index): Option[Int16] is
            if (value >= @embed(Index, "INT16_MIN")) and (value <= @embed(Index, "INT16_MAX")) then
                return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt16(Float32) is
        method toInt16(value: Float32): Option[Int16] is
            return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
        end;
    end;

    instance ToInt16(Float64) is
        method toInt16(value: Float64): Option[Int16] is
            return Some(value => @embed(Int16, "((au_int16_t)($1))", value));
        end;
    end;

    -- ToInt32

    instance ToInt32(Nat8) is
        method toInt32(value: Nat8): Option[Int32] is
            -- `Nat8` is strictly contained by `Int32`, so no checks are necessary.
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    instance ToInt32(Nat16) is
        method toInt32(value: Nat16): Option[Int32] is
            -- `Nat16` is strictly contained by `Int32`, so no checks are necessary.
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    instance ToInt32(Nat32) is
        method toInt32(value: Nat32): Option[Int32] is
            if value <= @embed(Nat32, "INT32_MAX") then
                return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt32(Nat64) is
        method toInt32(value: Nat64): Option[Int32] is
            if value <= @embed(Nat64, "INT32_MAX") then
                return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt32(Int8) is
        method toInt32(value: Int8): Option[Int32] is
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    instance ToInt32(Int16) is
        method toInt32(value: Int16): Option[Int32] is
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    instance ToInt32(Int32) is
        method toInt32(value: Int32): Option[Int32] is
            return Some(value => value);
        end;
    end;

    instance ToInt32(Int64) is
        method toInt32(value: Int64): Option[Int32] is
            if (value >= @embed(Int64, "INT32_MIN")) and (value <= @embed(Int64, "INT32_MAX")) then
                return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt32(Index) is
        method toInt32(value: Index): Option[Int32] is
            if value <= @embed(Index, "INT32_MAX") then
                return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt32(Float32) is
        method toInt32(value: Float32): Option[Int32] is
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    instance ToInt32(Float64) is
        method toInt32(value: Float64): Option[Int32] is
            return Some(value => @embed(Int32, "((au_int32_t)($1))", value));
        end;
    end;

    -- ToInt64

    instance ToInt64(Nat8) is
        method toInt64(value: Nat8): Option[Int64] is
            -- `Nat8` is strictly contained by `Int32`, so no checks are necessary.
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Nat16) is
        method toInt64(value: Nat16): Option[Int64] is
            -- `Nat16` is strictly contained by `Int64`, so no checks are necessary.
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Nat32) is
        method toInt64(value: Nat32): Option[Int64] is
            -- `Nat32` is strictly contained by `Int64`, so no checks are necessary.
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Nat64) is
        method toInt64(value: Nat64): Option[Int64] is
            if value <= @embed(Nat64, "INT64_MAX") then
                return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt64(Int8) is
        method toInt64(value: Int8): Option[Int64] is
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Int16) is
        method toInt64(value: Int16): Option[Int64] is
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Int32) is
        method toInt64(value: Int32): Option[Int64] is
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Int64) is
        method toInt64(value: Int64): Option[Int64] is
            return Some(value => value);
        end;
    end;

    instance ToInt64(Index) is
        method toInt64(value: Index): Option[Int64] is
            if (value >= @embed(Index, "INT64_MIN")) and (value <= @embed(Index, "INT64_MAX")) then
                return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToInt64(Float32) is
        method toInt64(value: Float32): Option[Int64] is
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    instance ToInt64(Float64) is
        method toInt64(value: Float64): Option[Int64] is
            return Some(value => @embed(Int64, "((au_int64_t)($1))", value));
        end;
    end;

    -- ToIndex

    instance ToIndex(Nat8) is
        method toIndex(value: Nat8): Option[Index] is
            return Some(value => @embed(Index, "((au_index_t)($1))", value));
        end;
    end;

    instance ToIndex(Nat16) is
        method toIndex(value: Nat16): Option[Index] is
            if (value <= @embed(Nat16, "SIZE_MAX")) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Nat32) is
        method toIndex(value: Nat32): Option[Index] is
            if (value <= @embed(Nat32, "SIZE_MAX")) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Nat64) is
        method toIndex(value: Nat64): Option[Index] is
            if (value <= @embed(Nat64, "SIZE_MAX")) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Int8) is
        method toIndex(value: Int8): Option[Index] is
            if (value >= 0) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Int16) is
        method toIndex(value: Int16): Option[Index] is
            if (value >= 0) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Int32) is
        method toIndex(value: Int32): Option[Index] is
            let cast: Index := @embed(Index, "((au_index_t)($1))", value);
            if (value >= 0) and (cast <= @embed(Index, "SIZE_MAX")) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Int64) is
        method toIndex(value: Int64): Option[Index] is
            if (value >= 0) and (value <= @embed(Int64, "SIZE_MAX")) then
                return Some(value => @embed(Index, "((au_index_t)($1))", value));
            else
                return None();
            end if;
        end;
    end;

    instance ToIndex(Index) is
        method toIndex(value: Index): Option[Index] is
            return Some(value => value);
        end;
    end;

    instance ToIndex(Float32) is
        method toIndex(value: Float32): Option[Index] is
            return Some(value => @embed(Index, "((au_index_t)($1))", value));
        end;
    end;

    instance ToIndex(Float64) is
        method toIndex(value: Float64): Option[Index] is
            return Some(value => @embed(Index, "((au_index_t)($1))", value));
        end;
    end;

    -- ToFloat32

    instance ToFloat32(Nat8) is
        method toFloat32(value: Nat8): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Nat16) is
        method toFloat32(value: Nat16): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Nat32) is
        method toFloat32(value: Nat32): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Nat64) is
        method toFloat32(value: Nat64): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Int8) is
        method toFloat32(value: Int8): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Int16) is
        method toFloat32(value: Int16): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Int32) is
        method toFloat32(value: Int32): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Int64) is
        method toFloat32(value: Int64): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Index) is
        method toFloat32(value: Index): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;

    instance ToFloat32(Float32) is
        method toFloat32(value: Float32): Option[Float32] is
            return Some(value => value);
        end;
    end;

    instance ToFloat32(Float64) is
        method toFloat32(value: Float64): Option[Float32] is
            return Some(value => @embed(Float32, "((float)($1))", value));
        end;
    end;


    -- ToFloat64

    instance ToFloat64(Nat8) is
        method toFloat64(value: Nat8): Option[Float64] is
            return Some(value => @embed(Float64, "((float)($1))", value));
        end;
    end;

    instance ToFloat64(Nat16) is
        method toFloat64(value: Nat16): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Nat32) is
        method toFloat64(value: Nat32): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Nat64) is
        method toFloat64(value: Nat64): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Int8) is
        method toFloat64(value: Int8): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Int16) is
        method toFloat64(value: Int16): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Int32) is
        method toFloat64(value: Int32): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Int64) is
        method toFloat64(value: Int64): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Index) is
        method toFloat64(value: Index): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Float32) is
        method toFloat64(value: Float32): Option[Float64] is
            return Some(value => @embed(Float64, "((double)($1))", value));
        end;
    end;

    instance ToFloat64(Float64) is
        method toFloat64(value: Float64): Option[Float64] is
            return Some(value => value);
        end;
    end;

    ---
    --- Remainder
    ---

    instance Remainder(Nat8) is
        method rem(lhs: Nat8, rhs: Nat8): Nat8 is
            if rhs = 0 then
               abort("Division by zero in rem(Nat8)");
            end if;
            return @embed(Nat8, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Nat16) is
        method rem(lhs: Nat16, rhs: Nat16): Nat16 is
            if rhs = 0 then
               abort("Division by zero in rem(Nat16)");
            end if;
            return @embed(Nat16, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Nat32) is
        method rem(lhs: Nat32, rhs: Nat32): Nat32 is
            if rhs = 0 then
               abort("Division by zero in rem(Nat32)");
            end if;
            return @embed(Nat32, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Nat64) is
        method rem(lhs: Nat64, rhs: Nat64): Nat64 is
            if rhs = 0 then
               abort("Division by zero in rem(Nat64)");
            end if;
            return @embed(Nat64, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Nat8) is
        method rem(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
               abort("Division by zero in rem(Int8)");
            end if;
            if (lhs = minimum_int8) and (rhs = -1) then
                abort("Overflow in rem(Int8)");
            end if;
            return @embed(Int8, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Int8) is
        method rem(lhs: Int8, rhs: Int8): Int8 is
            if rhs = 0 then
               abort("Division by zero in rem(Int8)");
            end if;
            if (lhs = minimum_int8) and (rhs = -1) then
                abort("Overflow in rem(Int8)");
            end if;
            return @embed(Int8, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Int16) is
        method rem(lhs: Int16, rhs: Int16): Int16 is
            if rhs = 0 then
               abort("Division by zero in rem(Int16)");
            end if;
            if (lhs = minimum_int16) and (rhs = -1) then
                abort("Overflow in rem(Int16)");
            end if;
            return @embed(Int16, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Int32) is
        method rem(lhs: Int32, rhs: Int32): Int32 is
            if rhs = 0 then
               abort("Division by zero in rem(Int32)");
            end if;
            if (lhs = minimum_int32) and (rhs = -1) then
                abort("Overflow in rem(Int32)");
            end if;
            return @embed(Int32, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Int64) is
        method rem(lhs: Int64, rhs: Int64): Int64 is
            if rhs = 0 then
               abort("Division by zero in rem(Int64)");
            end if;
            if (lhs = minimum_int64) and (rhs = -1) then
                abort("Overflow in rem(Int64)");
            end if;
            return @embed(Int64, "($1 % $2)", lhs, rhs);
        end;
    end;

    instance Remainder(Index) is
        method rem(lhs: Index, rhs: Index): Index is
            if rhs = 0 then
               abort("Division by zero in rem(Index)");
            end if;
            return @embed(Index, "($1 % $2)", lhs, rhs);
        end;
    end;
end module body.